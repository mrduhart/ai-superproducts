- runserver on 0.0.0.0 interface (localhost remains in container)

- Add 0.0.0.0 and docker-machine ip to settings
ALLOWED_HOSTS = ['0.0.0.0', '192.168.99.100']

- A project can contain multiple apps. An app can be in multiple projects.

- The URLconf matches a request's url (no domain name, no GET/POST parameters) to urlpatterns and then calls the view function. The request is given as argument to it, with parameters as keyword arguments.

- SQLite is enough for the tutorial, but should be replaced for production environments and larger projects (install bindings and configure database permisions and tables).

- Use UTC in the code and use local time only when interacting with end users: https://docs.djangoproject.com/en/3.0/topics/i18n/timezones/#:~:text=The%20solution%20to%20this%20problem,installed%20when%20you%20install%20Django.

- Time zones values are not UTC+-xy:wz https://stackoverflow.com/a/29311392/4281529

- Database migration creates necessary tables for each entry of INSTALLED_APPS

- Create docker image with database utilities, e.g. sqlite3

- To change models:
  1. Change models in models.py
  2. Create migrations for the models with python manage.py makemigrations
  3. Apply changes to database (migrate) with python manage.py migrate

- Django provides a database API for
  - Creation (insertion)
  - Filtering (querying)
  - Indexing
  - Deletion
  - Relation management

- Django sets up an admin site by default
  - Create users with python manage.py createsuperuser
  - Can be translated with LANGUAGE_CODE setting
  - Models need to be registered in their admin.py to appear here
  - We can edit a model's fields from here
  - We can look at the history of changes

- Views are akin to an API: take a request as input, and return a response
    - They can also take keyword arguments from the url pattern (mapped from the URLconf).
    - The logic in the view is up to the dev.

- Templates contain the html used by views
  - Work with Liquid
  - Loaded via loader.get_template and then rendered with a context (dictionary of arguments for the template)
  - Can also be rendered in a shortcut: request, template, context
  - Have dot-lookup access to object attributes in this order: dictionary lookup, attribute lookup, list-index lookup.

- A 404 error can be raised directly in a try-except block or through a shortcut that takes a model and keyword arguments for its manager (get_object_or_404 for get method, get_list_or_404 for filter method)

- The url liquid tag maps view names to url patterns
  - Helps to remove hardcoded urls
  - Can (should) be combined with app namespacing to resolve equally-named views

- Templates can include forms that work similar to PHP forms
  - POST for server-side data manipulation
  - Cross Site Request Forgeries are taken care by Django with {% csrf_token %}
  - The view should handle the request, accessing the POST dictionary, and return an HttpResponseRedirect
  - To avoid race conditions, use F() instead of changing data with Python

- For common and shared operations, use generic views instead of custom ones
  - URLconf calls them with the as_view method, giving a pk to DetailView
  - Views are replaced with ListView (displays a list of objects) and DetailView (displays details for a model) subclasses.
  - Template and context names are generated by default; can be specified
  - Evaluating during design vs refactoring later

- Testing is VERY important
    - To prevent, detect and solve errors
    - To increase code and product quality
    - To collaborate

- Automated testing avoids repeating work
    - Once a test is written, it is forever useful
    - Detects broken code as soon as new features are added
    - Base for test-driven development: write tests first, then code to pass them, then refactor and check tests again
    - Allows continuous integration

- Django includes tools for testing
    - Test file layout: app.tests.py
        - Contains classes and methods for testing
        - Give descriptive names to objects, begin method names with test_
    - Tools for testing: django.test
        - TestCase class for inheritance
        - Assertions
        - A test client for interacting with views: makes requests, receives responses with extra data (e.g. context, status codes)
    - Integration with automated-browser tools (e.g. Selenium): LiveServerTestCase
    - Command line utility: python manage.py test app
        - Runs tests and outputs results
        - Creates a test database (deleted after each test)

- Testing best practices
    - Don't be lazy, no "clever" refactoring of tests (is the code failing, or is it the test that's failing?)
    - More is better: once written, it's useful forever (partially)
    - Redundancy is good
    - Tests help look after themselves (did the code break it or is it no longer valid?)
    - Separate TestClass for each model and view
    - Separate method for each condition to test
    - Test methods names that describe their function
    - Code coverage for identifying which code is not tested yet

- Django takes care of static files for more complex apps: django.contrib.staticfiles
    - Put static files in a (namespaced) "static" directory in app
    - Set settings values for static files finders and base url
    - Include static tag in templates (but not in static files themselves; these should be relative paths)
